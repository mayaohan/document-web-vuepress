(window.webpackJsonp=window.webpackJsonp||[]).push([[169],{481:function(t,v,_){"use strict";_.r(v);var s=_(1),a=Object(s.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"强缓存和协议缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#强缓存和协议缓存"}},[t._v("#")]),t._v(" 强缓存和协议缓存")]),t._v(" "),v("blockquote",[v("p",[t._v("HTTP缓存机制是指在浏览器和服务器之间传输HTTP资源时，为了提高性能和减少网络流量，浏览器会使用一些策略来避免重复请求已经获取过的资源。")])]),t._v(" "),v("p",[v("strong",[t._v("HTTP缓存机制分为两类：强缓存和协商缓存。")])]),t._v(" "),v("h2",{attrs:{id:"强缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[t._v("#")]),t._v(" 强缓存")]),t._v(" "),v("p",[t._v("当浏览器第一次请求一个资源时，服务器可以通过设置HTTP响应头来告诉浏览器是否可以缓存该资源。如果可以，则浏览器将在下一次请求该资源时直接从本地缓存中获取，而不需要发送HTTP请求到服务器。")]),t._v(" "),v("p",[v("strong",[t._v("常用的HTTP响应头有：")])]),t._v(" "),v("ul",[v("li",[t._v("Cache-Control：控制缓存行为的主要方式。可以设置多个指令，例如max-age表示缓存的最长时间，单位为秒；"),v("strong",[t._v("no-cache")]),t._v("表示缓存但需要验证；"),v("strong",[t._v("no-store")]),t._v("表示禁止缓存。")]),t._v(" "),v("li",[t._v("Expires：与"),v("strong",[t._v("Cache-Control")]),t._v("类似，但使用的是绝对时间，即缓存到何时失效。")]),t._v(" "),v("li",[t._v("ETag：资源的标识符，由服务器生成，每次资源内容发生变化时都会更新。")])]),t._v(" "),v("h2",{attrs:{id:"协商缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[t._v("#")]),t._v(" 协商缓存")]),t._v(" "),v("p",[t._v("当浏览器再次请求一个已经缓存的资源时，它会向服务器发送一个HTTP请求，并带上上一次请求中获得的一些信息，例如"),v("strong",[t._v("If-Modified-Since")]),t._v("和"),v("strong",[t._v("If-None-Match")]),t._v("。服务器可以利用这些信息判断资源是否已经发生了变化，如果没有变化，则返回一个HTTP响应头，并告诉浏览器可以使用缓存中的资源。否则，服务器会返回新的资源并带上新的HTTP响应头。")]),t._v(" "),v("p",[v("strong",[t._v("常用的HTTP响应头有：")])]),t._v(" "),v("ul",[v("li",[t._v("Last-Modified：资源的最后修改时间，由服务器发送。")]),t._v(" "),v("li",[t._v("If-Modified-Since：客户端保存的上一次请求资源的最后修改时间。")]),t._v(" "),v("li",[t._v("ETag：与强缓存相同。")]),t._v(" "),v("li",[t._v("需要注意的是，在实际开发中，我们可以根据不同类型和频率的资源采用不同的缓存策略，以提高性能和用户体验。")])])])}),[],!1,null,null,null);v.default=a.exports}}]);