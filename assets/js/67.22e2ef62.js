(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{384:function(v,_,t){"use strict";t.r(_);var p=t(1),i=Object(p.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[_("strong",[v._v("写在前面")])]),v._v(" "),_("p",[v._v("JavaScript 是弱类型语言，在运行时才能确定变量类型。即使是如今流行的 TypeScript，也只是增加了编译时（编译成 JavaScript）的类型检测（对于编译器相信大家都有所了解，代码编译过程中编译器会进行词法分析、语法分析、语义分析、生成 AST 等处理）。")]),v._v(" "),_("p",[v._v("同样，JavaScript 引擎在执行 JavaScript 代码时，也会从上到下进行词法分析、语法分析、语义分析等处理，并在代码解析完成后生成 AST（抽象语法树），最终根据 AST 生成 CPU 可以执行的机器码并执行。")]),v._v(" "),_("p",[v._v("这个过程，我们后面统一描述为语法分析阶段。除了语法分析阶段，JavaScript 引擎在执行代码时还会进行其他的处理。以 V8 引擎为例，在 V8 引擎中 JavaScript 代码的运行过程主要分成三个阶段。")]),v._v(" "),_("ol",[_("li",[v._v("语法分析阶段。"),_("br"),v._v("\n该阶段会对代码进行语法分析，检查是否有语法错误（SyntaxError），如果发现语法错误，会在控制台抛出异常并终止执行。")]),v._v(" "),_("li",[v._v("编译阶段。"),_("br"),v._v("\n该阶段会进行执行上下文（Execution Context）的创建，包括创建变量对象、建立作用域链、确定 this 的指向等。每进入一个不同的运行环境时，V8 引擎都会创建一个新的执行上下文。")]),v._v(" "),_("li",[v._v("执行阶段。"),_("br"),v._v("\n将编译阶段中创建的执行上下文压入调用栈，并成为正在运行的执行上下文，代码执行结束后，将其弹出调用栈。")])]),v._v(" "),_("p",[v._v("其中，语法分析阶段属于编译器通用内容，就不再赘述。前面提到的执行环境、词法环境、作用域、执行上下文等内容都是在编译和执行阶段中产生的概念。")]),v._v(" "),_("p",[v._v("JavaScript 在运行过程中会产生一个调用栈，调用栈遵循 LIFO（先进后出，后进先出）原则即可。")]),v._v(" "),_("p",[_("strong",[v._v("执行上下文的创建")])]),v._v(" "),_("p",[v._v("执行上下文的创建离不开 JavaScript 的运行环境，JavaScript 运行环境包括全局环境、函数环境和eval，其中全局环境和函数环境的创建过程如下：")]),v._v(" "),_("p",[v._v("第一次载入 JavaScript 代码时，首先会创建一个全局环境。全局环境位于最外层，直到应用程序退出后（例如关闭浏览器和网页）才会被销毁。")]),v._v(" "),_("p",[v._v("每个函数都有自己的运行环境，当函数被调用时，则会进入该函数的运行环境。当该环境中的代码被全部执行完毕后，该环境会被销毁。不同的函数运行环境不一样，即使是同一个函数，在被多次调用时也会创建多个不同的函数环境。")]),v._v(" "),_("p",[v._v("在不同的运行环境中，变量和函数可访问的其他数据范围不同，环境的行为（比如创建和销毁）也有所区别。而每进入一个不同的运行环境时，JavaScript 都会创建一个新的执行上下文，该过程包括")]),v._v(" "),_("ol",[_("li",[v._v("建立作用域链（Scope Chain）；")]),v._v(" "),_("li",[v._v("创建变量对象（Variable Object，简称 VO）；")]),v._v(" "),_("li",[v._v("确定 this 的指向。")])]),v._v(" "),_("p",[v._v("由于建立作用域链过程中会涉及变量对象的概念，因此我们先来看看变量对象的创建，再看建立作用域链和确定 this 的指向。")]),v._v(" "),_("p",[v._v("在全局环境中，this指向全局对象（在浏览器中为window）。")]),v._v(" "),_("p",[v._v("在函数内部，this的值取决于函数被调用的方式，函数作为对象的方法被调用，this指向调用这个方法的对象，函数用作构造函数时（使用new关键字），它的this被绑定到正在构造的新对象，在类的构造函数中，this是一个常规对象，类中所有非静态的方法都会被添加到this的原型中。")]),v._v(" "),_("p",[v._v("在箭头函数中，this指向它被创建时的环境。")]),v._v(" "),_("p",[v._v("使用apply、call、bind等方式调用：根据 API 不同，可切换函数执行的上下文环境，即this绑定的对象。")]),v._v(" "),_("p",[v._v("可以看到，this在不同的情况下会有不同的指向，在 ES6 箭头函数还没出现之前，为了能正确获取某个运行环境下this对象，我们常常会使用var that = this;、var self = this;这样的代码将变量分配给this，便于使用。这种方式降低了代码可读性，因此如今这种做法不再被提倡，通过正确使用箭头函数，我们可以更好地管理作用域。")]),v._v(" "),_("p",[_("strong",[v._v("创建变量对象")])]),v._v(" "),_("p",[v._v("什么是变量对象呢？每个执行上下文都会有一个关联的变量对象，该对象上会保存这个上下文中定义的所有变量和函数。")]),v._v(" "),_("p",[v._v("而在浏览器中，全局环境的变量对象是window对象，因此所有的全局变量和函数都是作为window对象的属性和方法创建的。相应的，在 Node 中全局环境的变量对象则是global对象。")]),v._v(" "),_("p",[v._v("对于变量声明：此时会给变量分配内存，并将其初始化为undefined（该过程只进行定义声明，执行阶段才执行赋值语句）。")]),v._v(" "),_("p",[v._v("对于函数声明：此时会在内存里创建函数对象，并且直接初始化为该函数对象。")]),v._v(" "),_("p",[v._v("上述变量声明和函数声明的处理过程，便是我们常说的变量提升和函数提升，其中函数声明提升会优先于变量声明提升。因为变量提升容易带来变量在预期外被覆盖掉的问题，同时还可能导致本应该被销毁的变量没有被销毁等情况。因此 ES6 中引入了let和const关键字，从而使 JavaScript 也拥有了块级作用域。")]),v._v(" "),_("p",[v._v("或许你会感到疑惑，JavaScript 是怎么支持块级作用域的呢？这就涉及作用域的概念。")]),v._v(" "),_("p",[v._v("在各类编程语言中，作用域分为静态作用域和动态作用域。JavaScript 采用的是词法作用域（Lexical Scoping），也就是静态作用域。词法作用域中的变量，在编译过程中会产生一个确定的作用域。")]),v._v(" "),_("p",[v._v("到这里，或许你对会词法作用域、作用域、执行上下文、词法环境之间的关系依然感到混乱，没关系，一起梳理梳理下。")]),v._v(" "),_("p",[v._v("上述提到，词法作用域中的变量，在编译过程中会产生一个确定的作用域，这个作用域即当前的执行上下文，在 ES5 后我们使用词法环境（Lexical Environment）替代作用域来描述该执行上下文。因此，词法环境可理解为我们常说的作用域，同样也指当前的执行上下文（注意，是当前的执行上下文）。")]),v._v(" "),_("p",[v._v("在 JavaScript 中，词法环境又分为词法环境（Lexical Environment）和变量环境（Variable Environment）两种，其中：")]),v._v(" "),_("ol",[_("li",[v._v("变量环境用来记录var/function等变量声明；")]),v._v(" "),_("li",[v._v("词法环境是用来记录let/const/class等变量声明。")])]),v._v(" "),_("p",[v._v("也就是说，创建变量过程中会进行函数提升和变量提升，JavaScript 会通过词法环境来记录函数和变量声明。通过使用两个词法环境（而不是一个）分别记录不同的变量声明内容，JavaScript 实现了支持块级作用域的同时，不影响原有的变量声明和函数声明。")]),v._v(" "),_("p",[v._v("这就是创建变量的过程，它属于执行上下文创建中的一环。创建变量的过程会产生作用域，作用域也被称为词法环境，那词法环境是由什么组成的呢？下面我结合作用域链的建立过程一起来进行分析。")]),v._v(" "),_("p",[_("strong",[v._v("建立作用域链")])]),v._v(" "),_("p",[v._v("作用域链，顾名思义，就是将各个作用域通过某种方式连接在一起。")]),v._v(" "),_("p",[v._v("作用域就是词法环境，而词法环境由两个成员组成。")]),v._v(" "),_("p",[v._v("环境记录（Environment Record）：用于记录自身词法环境中的变量对象。")]),v._v(" "),_("p",[v._v("外部词法环境引用（Outer Lexical Environment）：记录外层词法环境的引用。")]),v._v(" "),_("p",[v._v("通过外部词法环境的引用，作用域可以层层拓展，建立起从里到外延伸的一条作用域链。当某个变量无法在自身词法环境记录中找到时，可以根据外部词法环境引用向外层进行寻找，直到最外层的词法环境中外部词法环境引用为null，这便是作用域链的变量查询。")]),v._v(" "),_("p",[v._v("那么，这个外部词法环境引用又是怎样指向外层呢？我们来看看 JavaScript 中是如何通过外部词法环境引用来创建作用域的。")]),v._v(" "),_("p",[v._v("为了方便描述，我们将 JavaScript 代码运行过程分为定义期和执行期，前面提到的编译阶段则属于定义期。")]),v._v(" "),_("p",[v._v("在定义期（编译阶段）：该对象值仍为undefined，且处于不可访问的状态。")]),v._v(" "),_("p",[v._v("进入执行期（执行阶段）：VO 被激活，其中变量属性会进行赋值。")]),v._v(" "),_("p",[v._v("实际上在执行的时候，除了 VO 被激活，活动对象还会添加函数执行时传入的参数和arguments这个特殊对象")]),v._v(" "),_("p",[v._v("从当前词法环境开始，沿着作用域链逐级向外层寻找环境记录，直到找到同名变量为止；")]),v._v(" "),_("p",[v._v("找到后不再继续遍历，找不到就报错。")])])}),[],!1,null,null,null);_.default=i.exports}}]);